# data file for pack-rig.mod
# Original AMPL coding by Sven Leyffer, University of Dundee

param n := 8;

# ... discretization (element/node table, conforming triangles)
set elements :=
    (   1,      2,     10  )
    (  11,     10,      2  )
    (   2,      3,     11  )
    (  12,     11,      3  )
    (   3,      4,     12  )
    (  13,     12,      4  )
    (   4,      5,     13  )
    (  14,     13,      5  )
    (   5,      6,     14  )
    (  15,     14,      6  )
    (   6,      7,     15  )
    (  16,     15,      7  )
    (   7,      8,     16  )
    (  17,     16,      8  )
    (   8,      9,     17  )
    (  18,     17,      9  )
    (  10,     11,     19  )
    (  20,     19,     11  )
    (  11,     12,     20  )
    (  21,     20,     12  )
    (  12,     13,     21  )
    (  22,     21,     13  )
    (  13,     14,     22  )
    (  23,     22,     14  )
    (  14,     15,     23  )
    (  24,     23,     15  )
    (  15,     16,     24  )
    (  25,     24,     16  )
    (  16,     17,     25  )
    (  26,     25,     17  )
    (  17,     18,     26  )
    (  27,     26,     18  )
    (  19,     20,     28  )
    (  29,     28,     20  )
    (  20,     21,     29  )
    (  30,     29,     21  )
    (  21,     22,     30  )
    (  31,     30,     22  )
    (  22,     23,     31  )
    (  32,     31,     23  )
    (  23,     24,     32  )
    (  33,     32,     24  )
    (  24,     25,     33  )
    (  34,     33,     25  )
    (  25,     26,     34  )
    (  35,     34,     26  )
    (  26,     27,     35  )
    (  36,     35,     27  )
    (  28,     29,     37  )
    (  38,     37,     29  )
    (  29,     30,     38  )
    (  39,     38,     30  )
    (  30,     31,     39  )
    (  40,     39,     31  )
    (  31,     32,     40  )
    (  41,     40,     32  )
    (  32,     33,     41  )
    (  42,     41,     33  )
    (  33,     34,     42  )
    (  43,     42,     34  )
    (  34,     35,     43  )
    (  44,     43,     35  )
    (  35,     36,     44  )
    (  45,     44,     36  )
    (  37,     38,     46  )
    (  47,     46,     38  )
    (  38,     39,     47  )
    (  48,     47,     39  )
    (  39,     40,     48  )
    (  49,     48,     40  )
    (  40,     41,     49  )
    (  50,     49,     41  )
    (  41,     42,     50  )
    (  51,     50,     42  )
    (  42,     43,     51  )
    (  52,     51,     43  )
    (  43,     44,     52  )
    (  53,     52,     44  )
    (  44,     45,     53  )
    (  54,     53,     45  )
    (  46,     47,     55  )
    (  56,     55,     47  )
    (  47,     48,     56  )
    (  57,     56,     48  )
    (  48,     49,     57  )
    (  58,     57,     49  )
    (  49,     50,     58  )
    (  59,     58,     50  )
    (  50,     51,     59  )
    (  60,     59,     51  )
    (  51,     52,     60  )
    (  61,     60,     52  )
    (  52,     53,     61  )
    (  62,     61,     53  )
    (  53,     54,     62  )
    (  63,     62,     54  )
    (  55,     56,     64  )
    (  65,     64,     56  )
    (  56,     57,     65  )
    (  66,     65,     57  )
    (  57,     58,     66  )
    (  67,     66,     58  )
    (  58,     59,     67  )
    (  68,     67,     59  )
    (  59,     60,     68  )
    (  69,     68,     60  )
    (  60,     61,     69  )
    (  70,     69,     61  )
    (  61,     62,     70  )
    (  71,     70,     62  )
    (  62,     63,     71  )
    (  72,     71,     63  )
    (  64,     65,     73  )
    (  74,     73,     65  )
    (  65,     66,     74  )
    (  75,     74,     66  )
    (  66,     67,     75  )
    (  76,     75,     67  )
    (  67,     68,     76  )
    (  77,     76,     68  )
    (  68,     69,     77  )
    (  78,     77,     69  )
    (  69,     70,     78  )
    (  79,     78,     70  )
    (  70,     71,     79  )
    (  80,     79,     71  )
    (  71,     72,     80  )
    (  81,     80,     72  ) ;

# ... i-j coordinates (i=0 => x=0, i=n => x=1 etc)
param: i_ref, j_ref   :=
    1    0    0   
    2    1    0   
    3    2    0   
    4    3    0   
    5    4    0   
    6    5    0   
    7    6    0   
    8    7    0   
    9    8    0   
   10    0    1   
   11    1    1   
   12    2    1   
   13    3    1   
   14    4    1   
   15    5    1   
   16    6    1   
   17    7    1   
   18    8    1   
   19    0    2   
   20    1    2   
   21    2    2   
   22    3    2   
   23    4    2   
   24    5    2   
   25    6    2   
   26    7    2   
   27    8    2   
   28    0    3   
   29    1    3   
   30    2    3   
   31    3    3   
   32    4    3   
   33    5    3   
   34    6    3   
   35    7    3   
   36    8    3   
   37    0    4   
   38    1    4   
   39    2    4   
   40    3    4   
   41    4    4   
   42    5    4   
   43    6    4   
   44    7    4   
   45    8    4   
   46    0    5   
   47    1    5   
   48    2    5   
   49    3    5   
   50    4    5   
   51    5    5   
   52    6    5   
   53    7    5   
   54    8    5   
   55    0    6   
   56    1    6   
   57    2    6   
   58    3    6   
   59    4    6   
   60    5    6   
   61    6    6   
   62    7    6   
   63    8    6   
   64    0    7   
   65    1    7   
   66    2    7   
   67    3    7   
   68    4    7   
   69    5    7   
   70    6    7   
   71    7    7   
   72    8    7   
   73    0    8   
   74    1    8   
   75    2    8   
   76    3    8   
   77    4    8   
   78    5    8   
   79    6    8   
   80    7    8   
   81    8    8   ;

# ... boundary nodes
set bnd_nodes :=    1,   2,   3,   4,   5,   6,   7,   8,   
                    9,  18,  27,  36,  45,  54,  63,  72,  
                   10,  19,  28,  37,  46,  55,  64,  73,  
                   81,  80,  79,  78,  77,  76,  75,  74 ;

# ... boundary conditions
let{i in bnd_nodes} u0[i] := 0.0;

# ... region, where membrane is fixed to obstacle (in interior)
let Omega0 := { };
for {k in int_nodes}  
   if (n<=4*i_ref[k])&&(4*i_ref[k]<=2*n)&&
      (n<=4*j_ref[k])&&(4*j_ref[k]<=3*n) 
   then { let Omega0 := Omega0 union { k } };

# ... set fixed nodes
let fix_nodes := { };
for {k in nodes}
   if i_ref[k]<=n/2 then { let fix_nodes := fix_nodes union { k } };


