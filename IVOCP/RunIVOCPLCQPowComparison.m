%% Clear and Close
clc; clear all; close all;

%% Build benchmark
benchmark = {};
benchmark.problems = {};

benchmark.solvers = { ...
    struct('fun', 'SolveLCQPow1'), ... 
    struct('fun', 'SolveLCQPow1_NoLeyffer'), ... 
};

% Append solvers by specifying a solver strategy and solver name
% Each solver is assumed to take the input of a benchmark.problem struct
% and return [x, y, stats]
% benchmark.solvers = { ...
%     struct('fun', 'SolveLCQPow0'), ... 
%     struct('fun', 'SolveLCQPow1'), ... 
%     struct('fun', 'SolveLCQPow2'), ... 
%     struct('fun', 'SolveLCQPow0_SmallRho0'), ... 
%     struct('fun', 'SolveLCQPow1_SmallRho0'), ... 
%     struct('fun', 'SolveLCQPow2_SmallRho0'), ... 
%     struct('fun', 'SolveLCQPow0_SmallFast'), ... 
%     struct('fun', 'SolveLCQPow1_SmallFast'), ... 
%     struct('fun', 'SolveLCQPow2_SmallFast'), ... 
%     struct('fun', 'SolveLCQPow0_SmallSlow'), ... 
%     struct('fun', 'SolveLCQPow1_SmallSlow'), ... 
%     struct('fun', 'SolveLCQPow2_SmallSlow'), ... 
%     struct('fun', 'SolveLCQPow0_LargeRho0'), ... 
%     struct('fun', 'SolveLCQPow1_LargeRho0'), ... 
%     struct('fun', 'SolveLCQPow2_LargeRho0'), ... 
%     struct('fun', 'SolveLCQPow0_NoLeyffer'), ... 
%     struct('fun', 'SolveLCQPow1_NoLeyffer'), ... 
%     struct('fun', 'SolveLCQPow2_NoLeyffer'), ... 
%     struct('fun', 'SolveLCQPow0_LowStationarity'), ... 
%     struct('fun', 'SolveLCQPow1_LowStationarity'), ... 
%     struct('fun', 'SolveLCQPow2_LowStationarity'), ... 
%     struct('fun', 'SolveLCQPow0_LowComplementarity'), ... 
%     struct('fun', 'SolveLCQPow1_LowComplementarity'), ... 
%     struct('fun', 'SolveLCQPow2_LowComplementarity'), ... 
%     struct('fun', 'SolveLCQPow2_LowPrecision'), ... 
%     struct('fun', 'SolveLCQPow1_LowPrecision'), ... 
%     struct('fun', 'SolveLCQPow0_LowPrecision'), ... 
% };

% Generate problems
i = 1;
for N = 50:5:60
    for x00 = linspace(-1.9, -0.9, 10)
        benchmark.problems{i}.T = 2;
        benchmark.problems{i}.N = N;    
        benchmark.problems{i}.x00 = x00;    
        benchmark.problems{i}.casadi_formulation = GetIVOCP(2, N, x00);        
        i = i+1;
    end
end

%% Run Solvers
addpath("../solvers");
addpath("../solvers/LCQPowVariants/");
for i = 1:length(benchmark.problems)    
    fprintf("Solving problem %s (%d/%d).\n", string(benchmark.problems{i}.N), i, length(benchmark.problems));
    for j = 1:length(benchmark.solvers)
        solver = benchmark.solvers{j};
        benchmark.problems{i}.solutions{j} = feval(solver.fun, benchmark.problems{i}.casadi_formulation);
        benchmark.problems{i}.solutions{j}.solver = benchmark.solvers{j};
    end
end

outdir = 'solutions/LCQPow_comparison';
if ~exist(outdir, 'dir')
   mkdir(outdir)
end

save(outdir + "/sol.mat");

%% Create Performance Plots
close all; clear all; clc;
outdir = 'solutions/LCQPow_comparison';
load(fullfile(outdir, 'sol.mat'));
addpath("helpers");
addpath("../helpers");

% Get the solver visualization settings
for s=1:length(benchmark.solvers)
    for p=1:length(benchmark.problems)
        benchmark.problems{p}.solutions{s}.solver.style = GetPlotStyleLCQPowComparison(benchmark.problems{p}.solutions{s}.solver.fun);
    end
end

%% Complementarity tolerance
close all; comp_tol = 10e-9;

% Set to latex
set(groot,'defaultAxesTickLabelInterpreter','latex');
set(groot,'defaulttextinterpreter','latex');
set(groot,'defaultLegendInterpreter','latex');

% Create the plots
PlotTimings(benchmark.problems, 'IVOCP', outdir, comp_tol);
PlotAccuracyIVOCP(benchmark.problems, 'IVOCP', outdir, comp_tol);
